# 2. [code] 爬楼梯

## 2.1. 题目

[Leetcode70:](https://leetcode-cn.com/problems/climbing-stairs)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：给定 n 是一个正整数。**

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

## 2.2. 思路

动态规划问题

可以发现，因为一次可以爬1层或者2层，所以爬到第i层台阶的方法数=爬到第i-1层的方法数+爬到第i-2层的方法数

```
dp[i] = dp[i-1]+dp[i-2];
```

## 2.3. 代码

```c++
class Solution {
public:
    int climbStairs(int n) {
        std::vector<int> dp(n+3,1);
        dp[2]=2;
        for (int i = 3; i < n; ++i){
            dp[i] = dp[i-1]+dp[i-2];
        }
        return dp[n];
    }
};
```

内存优化：

可以发现上述代码中，for循环中，只有dp[i-1]，dp[i-2]，dp[i]是有用的，dp中i-1之前的元素使用过后是可以释放的。

即用a b c三个变量即可完成上述代码。
```
=======================i=2：==============================

行号0 : dp[0] 1       ----> a
行号1 : dp[1] 1       ----> b
行号2 : dp[2] 1+1=2   ----> c = a+b
行号3 : dp[1] 1+2=3 
...
行号n : dp[n]  

=======================i=3：=============================

行号0 : dp[0] 1       
行号1 : dp[1] 1       ----> a  //a=上一个b
行号2 : dp[2] 1+1=2   ----> b  //b=上一个c
行号3 : dp[1] 1+2=3   ----> c = a+b
...
行号n : dp[n]
.
.
.

======================i=n：===========================

行号0 : dp[0] 1  
...     
行号n-2 : dp[n-1]       ----> a //a=上一个b
行号n-1 : dp[n-2]       ----> b //b=上一个c
行号n   : dp[n]         ----> c = a+b 返回该值
```

(即斐波那契数列)

```c++
class Solution {
public:
    int climbStairs(int n) {
        int a = 1;
        int b = 1;
        for (int i = 2; i <= n; ++i){
            c = a+b;
            a = b;
            b = c;
        }
        return c;
    }
};
```