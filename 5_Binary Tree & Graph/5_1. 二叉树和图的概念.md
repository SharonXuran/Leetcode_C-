# 1. 二叉树和图的概念

# 1.1. 二叉树

二叉树的数据结构
```c++
struct TreeNode{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x): val(x),left(NULL),right(NULL){}
};
```

二叉树的遍历
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

前、中、后序遍历，又称为深度优秀搜索(深搜)

前序遍历：5-4-11-7-2-8-13-4-5-1

中序遍历：7-11-2-4-5-13-8-5-4-1

后序遍历：7-2-11-4-13-5-1-4-8-5


```c++
void traversal(TreeNode *node){
    if (!node){
        return;
    }
    //此时访问node, 称为 【前序遍历】
    traversal(node->left);
    //此时访问node, 称为 【中序遍历】
    traversal(node->right);
    //此时访问node, 称为 【后序遍历】
}
```

层次遍历，又称为宽度优秀搜索(宽搜)

上述二叉树的层次遍历：5-4-8-11-13-4-7-2-5-1

用队列这种数据结构来实现二叉树的宽搜

```c++
#include <queue>
void BFS(TreeNode* root){
    std::queue<TreeNode*> Q;
    Q.push(root);
    while(!Q.empty()){
        TreeNode *node = Q.front();
        Q.pop();
        printf("[%d]\n", node->val);
        if (node->left){
            Q.push(node->left);
        }
        if (node->right){
            Q.push(node->right);
        }
    }
}
```

# 1.2. 图

图的定义：

G(V,E)，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

根据有无方向，图分为**有向图**和**无向图**；

根据图边长是否带权重，图分为**带权图**和**不带权图**。

图的表示：

**邻接矩阵**和 **邻接表**

邻接矩阵打印处理大致如下：

```
0 1 0 0 // 节点0连向节点1
0 0 1 0 // 节点1连向节点2
1 0 0 0 // 节点2连向节点0
1 0 1 0 // 节点3连向节点0和节点2
```

用邻接表打印大致如下：

```
0: 1
1: 2
2: 0
3: 0 2
```

图的邻接表的数据结构：

```c++
struct GraphNode{
    int label;
    std::vector<GraphNode*> neighbors;
    GraphNode(int x): label(x) {};
};
```

图的深搜：

```c++
void DFS_graph(GraphNode* node, int visit[]){
    // visit[i]表示节点i是否被访问，0表示没有被访问，1表示被访问了
    visit[node->label] = 1;
    printf("%d", node->label);
    for (int i = 0; i < node->neighbors.size(); ++i){
        if (visit[node->neighbors[i]->label] == 0){
            DFS_graph(node->neighbors[i],visit);
        }
    }
}
```

图的宽搜：

与树的宽搜类似，也用队列来实现。

```c++
void BFS_graph(GraphNode* node, int visit[]){
    std::queue<GraphNode*> Q;
    Q.push(node);
    visit[node->label] = 1;

    while(!Q.empty()){
        GraphNode* node = Q.front();
        Q.pop();
        printf("%d", node->label);
        for (int i = 0; i < node->neighbors.size(); ++i){
            if (visit[node->neighbors[i]->label]==0){
                Q.push[node->neighbors[i]];
                visit[node->neighbors[i]->label] = 1;
            }
        }
    }

}
```